#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AI Agent Orchestrator
Coordinates and manages the entire QA workflow as the brain of the system/APP
Using LangChain to orchestrate the components
"""

import time
from typing import Dict, Any, Optional
from .query_analyzer import QueryAnalyzer
from .router import Router
from .reranker import Reranker
from .synthesizer import Synthesizer
# from ..retrieval.manager import RetrievalManager

class AIAgent:
    """AI Agent Orchestrator"""

    def __init__(self):
        """Initialize pipeline components."""
        self.query_analyzer = QueryAnalyzer()
        self.router = Router()
        # self.retrieval_manager = RetrievalManager()
        self.reranker = Reranker()
        self.synthesizer = Synthesizer()

    def run(self, user_input: Dict[str, Any]) -> Any:
        """
        Orchestrate the  pipeline

        Args:
            user_input: Dictionay containing:
                - query: user question
                - images: list of uploaded image file paths

        Returns:
            Final answer generated by the AI agent
        """
        try:
            print("\n" + "="*25 + " New Query " + "="*25)
            start_time = time.time()
            # Extract query and context (parsed by pre-processing step)
            query = user_input.get("query", "")
            images = user_input.get("images", [])
            

            # 2.1) Perform query analysis to enhance the query for better retrieval
            analysis_results = self.query_analyzer.analyze(query, images=images)
            # print(f"ðŸ§  Enhanced query after the analysis: {analysis_results['enhanced_query']}")

            # Return only the analysis results for testing
            print(f"â±ï¸ Query analysis time: {time.time() - start_time:.2f} seconds")
            print("="*61)
            
            return {
                'answer': f"Testing with query analyzer module only.",
                'sources': [],
                'confidence': 1.0,
                'analysis_results': analysis_results
            }

            # # 2.2) Route to appropriate retrievers
            # routing_results = self.router.route(query, analysis_results['enhanced_query'])
            # print(f"ðŸ”€ Routing to: {', '.join(routing_results['selected_tools'])}")

            # # 3) Retrieve documents
            # retrieval_results = self.retrieval_manager.retrieve_from_multiple(
            #     retriever_names=routing_results['selected_tools'],
            #     query=query,
            #     top_k=routing_results.get('top_k', 10)
            # )
            # print(f"Retrieved {len(retrieval_results)} documents")

            # # 4) Rerank documents
            # reranked_results = self.reranker.rerank(
            #     query=query,
            #     documents=retrieval_results,
            #     top_k=5
            # )    
            # print(f"â­ Reranked to top {len(reranked_results)} documents")

            # # 5) Synthesize final answer
            # final_answer = self.synthesizer.generate_answer(
            #     query=query,
            #     retrieved_results=reranked_results
            # )
            # print(f"âœï¸ Generated answer with {len(final_answer['sources'])} sources")
            # print(f"â±ï¸ Total time: {time.time() - start_time:.2f} seconds")
            # print("===========================")

            # return {
            #     'answer': final_answer['answer'],
            #     'sources': final_answer['sources'],
            #     'confidence': final_answer.get('confidence', 0.0),
            #     'routing_info': routing_results,
            #     'retrieval_count': len(retrieval_results),
            #     'reranked_count': len(reranked_results)
            # }
    
        except Exception as e:
            print(f"âŒ å¤„ç†æŸ¥è¯¢æ—¶å‘ç”Ÿé”™è¯¯: {e}")
            return {
                'answer': f"æŠ±æ­‰ï¼Œå¤„ç†æ‚¨çš„é—®é¢˜æ—¶é‡åˆ°äº†é”™è¯¯: {str(e)}",
                'sources': [],
                'confidence': 0.0,
                'error': str(e)
            }

    async def health_check(self) -> Dict[str, bool]:
        """Check health status of each component"""
        try:
            return {
                'query_analyzer': await self.query_analyzer.health_check(),
                'router': await self.router.health_check(),
                # Comment out this line since retrieval_manager is not initialized
                # 'retrieval_manager': await self.retrieval_manager.health_check(),
                'reranker': await self.reranker.health_check(),
                'synthesizer': await self.synthesizer.health_check()
            }
        except Exception as e:
            print(f"Health check error: {e}")
            return {
                'query_analyzer': False,
                'router': False,
                'retrieval_manager': False,  # You can keep this in the error return
                'reranker': False,
                'synthesizer': False
            }