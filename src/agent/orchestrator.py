#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AI Agent Orchestrator
Coordinates and manages the entire QA workflow as the brain of the system/APP
Using LangChain to orchestrate the components
"""

import time
from typing import Dict, Any
from .query_analyzer import QueryAnalyzer
from .router import Router
from .reranker import Reranker
from .synthesizer import Synthesizer
from ..retrieval.manager import retrieval_manager

class AIAgent:
    """AI Agent Orchestrator"""

    def __init__(self):
        """Initialize pipeline components."""
        self.query_analyzer = QueryAnalyzer()
        self.router = Router()
        # self.retrieval_manager = retrieval_manager
        # self.reranker = Reranker()
        # self.synthesizer = Synthesizer()

    def run(self, user_input: Dict[str, Any]) -> Any:
        """
        Orchestrate the  pipeline

        Args:
            user_input: Dictionay containing:
                - raw_query: Original user query string
                - attachments: list of structured attachment data
                - attachment_issues: list of issues identified during preprocessing

        Returns:
            Final answer generated by the AI agent
        """
        try:
            print("\n" + "=" * 100)
            print("ðŸš€ Starting Query Processing Pipeline")
            print("=" * 100)
            start_time = time.time()
            
            # Extract query and context (parsed by pre-processing step)
            query = user_input.get("raw_query", "")
            attachments = user_input.get("attachments", [])
            attachment_contents = [att['content'] for att in attachments if 'content' in att]

            print("\nðŸ“¥ **Input Details:**")
            print(f"  - Raw Query: {query}")
            print(f"  - Number of Attachments: {len(attachments)}")
            if attachments:
                print("  - Attachment Details:")
                for i, att in enumerate(attachments, 1):
                    print(f"    {i}. Path: {att.get('path', 'N/A')}, Type: {att.get('type', 'N/A')}")

            # Step 1: Perform query analysis
            print("\nðŸ” **Step 1: Query Analysis**")
            analysis_results = self.query_analyzer.analyze(query=query, attachment_contents=attachment_contents)
            print(f"  - Rewritten Query: {analysis_results['rewritten_query']}")
            print(f"  - Keywords: {', '.join(analysis_results['keywords'])}")
            print(f"  - Query Type: {analysis_results['query_type']}")
            print(f"  - Complexity: {analysis_results['complexity']}")
            print(f"  - Domain Areas: {', '.join(analysis_results['domain_areas'])}")
            # print(f"  - Intent: {analysis_results['intent']}")
            print(f"  - Retriever Metadata: {analysis_results['retriever_metadata']}")

            print("\nâ±ï¸ **Processing Time:**")
            print(f"  - Query Analysis Time: {time.time() - start_time:.2f} seconds")
            print("=" * 100)

            # Step 2: Route to appropriate retrievers
            print("\nðŸ”€ **Step 2: Routing**")
            routing_results = self.router.route(analysis_results)
            print(f"  - Routing to: {routing_results['selected_tool']}")
            print(f"  - Reasoning: {routing_results['reasoning']}")
            print("\nâ±ï¸ **Processing Time:**")
            print(f"  - Query Analysis Time: {time.time() - start_time:.2f} seconds")
            print("=" * 100)

            # Step 3: Call the selected retriever to get documents
            print("\nðŸ“š **Step 3: Retrieval**")
            try:
                retrieval_results = self.retrieval_manager.retrieve(
                    name=routing_results['selected_tool'],
                    query=analysis_results['rewritten_query'],
                )
                if not retrieval_results.documents:
                    raise RuntimeError(f"No documents retrieved using retriever '{routing_results['selected_tool']}'")
                print(f"Retrieved {len(retrieval_results)} documents")
            except Exception as e:
                print(f"âš ï¸ Retrieval failed with retriever '{routing_results['selected_tool']}': {e}")
                print("  - Falling back to 'web_search' retriever...")
                retrieval_results = self.retrieval_manager.retrieve(
                    name="web_search",
                    query=analysis_results['rewritten_query']
                )
                if not retrieval_results.documents:
                    raise RuntimeError("Fallback to 'web_search' also failed")
                print(f"  - Retrieved {len(retrieval_results.documents)} documents using 'web_search'")

            return {
                'answer': f"Testing with query analyzer and routing module only.",
                'sources': [],
                'confidence': 1.0,
                'analysis_results': analysis_results
            }

            # # 4) Rerank documents
            # reranked_results = self.reranker.rerank(
            #     query=query,
            #     documents=retrieval_results,
            #     top_k=5
            # )    
            # print(f"â­ Reranked to top {len(reranked_results)} documents")

            # # 5) Synthesize final answer
            # final_answer = self.synthesizer.generate_answer(
            #     query=query,
            #     retrieved_results=reranked_results
            # )
            # print(f"âœï¸ Generated answer with {len(final_answer['sources'])} sources")
            # print(f"â±ï¸ Total time: {time.time() - start_time:.2f} seconds")
            # print("===========================")

            # return {
            #     'answer': final_answer['answer'],
            #     'sources': final_answer['sources'],
            #     'confidence': final_answer.get('confidence', 0.0),
            #     'routing_info': routing_results,
            #     'retrieval_count': len(retrieval_results),
            #     'reranked_count': len(reranked_results)
            # }
    
        except Exception as e:
            print(f"âŒ Error during query processing: {e}")
            return {
                'answer': f"Sorry, an error occurred while processing your query: {str(e)}",
                'sources': [],
                'confidence': 0.0,
                'error': str(e)
            }

    async def health_check(self) -> Dict[str, bool]:
        """Check health status of each component"""
        try:
            return {
                'query_analyzer': await self.query_analyzer.health_check(),
                'router': await self.router.health_check(),
                # Comment out this line since retrieval_manager is not initialized
                # 'retrieval_manager': await self.retrieval_manager.health_check(),
                'reranker': await self.reranker.health_check(),
                'synthesizer': await self.synthesizer.health_check()
            }
        except Exception as e:
            print(f"Health check error: {e}")
            return {
                'query_analyzer': False,
                'router': False,
                'retrieval_manager': False,  # You can keep this in the error return
                'reranker': False,
                'synthesizer': False
            }