#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AI Agent Orchestrator
Coordinates and manages the entire QA workflow as the brain of the system/APP
Using LangChain to orchestrate the components
"""

import time
from typing import Dict, Any, Optional
from .query_analyzer import QueryAnalyzer
from .router import Router
from .reranker import Reranker
from .synthesizer import Synthesizer
# from ..retrieval.manager import RetrievalManager

class AIAgent:
    """AI Agent Orchestrator"""

    def __init__(self):
        """Initialize pipeline components."""
        self.query_analyzer = QueryAnalyzer()
        self.router = Router()
        # self.retrieval_manager = RetrievalManager()
        self.reranker = Reranker()
        self.synthesizer = Synthesizer()

    def run(self, user_input: Dict[str, Any]) -> Any:
        """
        Orchestrate the  pipeline

        Args:
            user_input: Dictionay containing:
                - raw_query: Original user query string
                - attachments: list of structured attachment data
                - attachment_issues: list of issues identified during preprocessing

        Returns:
            Final answer generated by the AI agent
        """
        try:
            print("\n" + "=" * 50)
            print("ðŸš€ Starting Query Processing Pipeline")
            print("=" * 50)
            start_time = time.time()
            
            # Extract query and context (parsed by pre-processing step)
            query = user_input.get("raw_query", "")
            attachments = user_input.get("attachments", [])
            attachment_contents = [att['content'] for att in attachments if 'content' in att]

            print("\nðŸ“¥ **Input Details:**")
            print(f"  - Raw Query: {query}")
            print(f"  - Number of Attachments: {len(attachments)}")
            if attachments:
                print("  - Attachment Details:")
                for i, att in enumerate(attachments, 1):
                    print(f"    {i}. Path: {att.get('path', 'N/A')}, Type: {att.get('type', 'N/A')}")

            # Step 1: Perform query analysis
            print("\nðŸ” **Step 1: Query Analysis**")
            analysis_results = self.query_analyzer.analyze(query=query, attachment_contents=attachment_contents)
            print(f"  - Rewritten Query: {analysis_results['rewritten_query']}")
            print(f"  - Keywords: {', '.join(analysis_results['keywords'])}")
            print(f"  - Query Type: {analysis_results['query_type']}")
            print(f"  - Complexity: {analysis_results['complexity']}")
            print(f"  - Domain Areas: {', '.join(analysis_results['domain_areas'])}")
            print(f"  - Intent: {analysis_results['intent']}")

            # Return only the analysis results for testing
            print("\nâ±ï¸ **Processing Time:**")
            print(f"  - Query Analysis Time: {time.time() - start_time:.2f} seconds")
            print("=" * 50)
            
            return {
                'answer': f"Testing with query analyzer module only.",
                'sources': [],
                'confidence': 1.0,
                'analysis_results': analysis_results
            }

            # # 2.2) Route to appropriate retrievers
            # routing_results = self.router.route(query, analysis_results['enhanced_query'])
            # print(f"ðŸ”€ Routing to: {', '.join(routing_results['selected_tools'])}")

            # # 3) Retrieve documents
            # retrieval_results = self.retrieval_manager.retrieve_from_multiple(
            #     retriever_names=routing_results['selected_tools'],
            #     query=query,
            #     top_k=routing_results.get('top_k', 10)
            # )
            # print(f"Retrieved {len(retrieval_results)} documents")

            # # 4) Rerank documents
            # reranked_results = self.reranker.rerank(
            #     query=query,
            #     documents=retrieval_results,
            #     top_k=5
            # )    
            # print(f"â­ Reranked to top {len(reranked_results)} documents")

            # # 5) Synthesize final answer
            # final_answer = self.synthesizer.generate_answer(
            #     query=query,
            #     retrieved_results=reranked_results
            # )
            # print(f"âœï¸ Generated answer with {len(final_answer['sources'])} sources")
            # print(f"â±ï¸ Total time: {time.time() - start_time:.2f} seconds")
            # print("===========================")

            # return {
            #     'answer': final_answer['answer'],
            #     'sources': final_answer['sources'],
            #     'confidence': final_answer.get('confidence', 0.0),
            #     'routing_info': routing_results,
            #     'retrieval_count': len(retrieval_results),
            #     'reranked_count': len(reranked_results)
            # }
    
        except Exception as e:
            print(f"âŒ å¤„ç†æŸ¥è¯¢æ—¶å‘ç”Ÿé”™è¯¯: {e}")
            return {
                'answer': f"æŠ±æ­‰ï¼Œå¤„ç†æ‚¨çš„é—®é¢˜æ—¶é‡åˆ°äº†é”™è¯¯: {str(e)}",
                'sources': [],
                'confidence': 0.0,
                'error': str(e)
            }

    async def health_check(self) -> Dict[str, bool]:
        """Check health status of each component"""
        try:
            return {
                'query_analyzer': await self.query_analyzer.health_check(),
                'router': await self.router.health_check(),
                # Comment out this line since retrieval_manager is not initialized
                # 'retrieval_manager': await self.retrieval_manager.health_check(),
                'reranker': await self.reranker.health_check(),
                'synthesizer': await self.synthesizer.health_check()
            }
        except Exception as e:
            print(f"Health check error: {e}")
            return {
                'query_analyzer': False,
                'router': False,
                'retrieval_manager': False,  # You can keep this in the error return
                'reranker': False,
                'synthesizer': False
            }