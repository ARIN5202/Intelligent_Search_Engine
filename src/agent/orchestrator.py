#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AI Agent Orchestrator
Coordinates and manages the entire QA workflow as the brain of the system/APP
Using LangChain to orchestrate the components
"""

import time, os
import traceback
from typing import Dict, Any, List
from .query_analyzer import QueryAnalyzer
from .router import Router
from .reranker import Reranker
from .synthesizer import Synthesizer
from ..retrieval.manager import retrieval_manager
from config import get_settings
from .reranker import RerankResult

settings = get_settings()


class AIAgent:
    """AI Agent Orchestrator"""

    def __init__(self):
        """Initialize pipeline components."""
        self.query_analyzer = QueryAnalyzer()
        self.router = Router()
        self.retrieval_manager = retrieval_manager
        self.reranker = Reranker()
        self.synthesizer = Synthesizer(deployment_name="gpt-4o")

    def _retrieve_documents(
            self,
            routing_results: Dict[str, Any],
            analysis_results: Dict[str, Any],
    ) -> RerankResult:
        """Retrieve documents based on routing results and rerank them."""
        start = time.time()

        # å®‰å…¨ä¸€ç‚¹åœ°æ‹¿ queryï¼Œé¿å… key ä¸å­˜åœ¨ç›´æŽ¥ KeyError
        query = (
                analysis_results.get("rewritten_query")
                or analysis_results.get("query")
                or ""
        )

        try:
            selected_tool = routing_results["selected_tool"]
            retrieval_metadata = routing_results.get("retrieval_metadata", {})  # é˜²å¾¡æ€§ä¸€ç‚¹

            if selected_tool == "transport":
                retrieval_results = self.retrieval_manager.retrieve(
                    name="transport",
                    query=query,
                    origin=retrieval_metadata["origin"],
                    destination=retrieval_metadata["destination"],
                    mode=retrieval_metadata["transit_mode"],
                    top_k=10,
                )
            elif selected_tool == "finance":
                retrieval_results = self.retrieval_manager.retrieve(
                    name="finance",
                    query=query,
                    symbol=retrieval_metadata["ticker_symbol"],
                    top_k=10,
                )
            elif selected_tool == "weather":
                retrieval_results = self.retrieval_manager.retrieve(
                    name="weather",
                    query=query,
                    location=retrieval_metadata["location"],
                    top_k=10,
                )
            elif selected_tool == "local_rag":
                retrieval_results = self.retrieval_manager.retrieve(
                    name="local_rag",
                    query=query,
                    top_k=10,
                )
            else:
                retrieval_results = self.retrieval_manager.retrieve(
                    name="web_search",
                    query=query,
                    top_k=10,
                )

            print(
                f"  - Retrieved {len(retrieval_results.documents)} documents "
                f"using '{selected_tool}' retriever"
            )
            # Step 4: rerank the retrieved documents
            rerank_results: RerankResult = self.reranker.rerank_from_results(
                query=query,
                retrieval_results=[retrieval_results],
                top_k=5,
            )

            return rerank_results

        except Exception as e:
            tool_name = routing_results.get("selected_tool", "unknown")
            print(f"âš ï¸ Retrieval and reranking failed for '{tool_name}': {e}")
            # å¦‚æžœä½ æƒ³çœ‹æ›´è¯¦ç»† traceï¼Œå¯ä»¥æ‰“å¼€ä¸‹é¢è¿™è¡Œ
            # print(traceback.format_exc())

            # â—å…³é”®ï¼šå¼‚å¸¸æ—¶ä»ç„¶è¿”å›ž RerankResultï¼Œè€Œä¸æ˜¯ dict
            return RerankResult(
                query=query,
                contexts=[],  # ç©ºä¸Šä¸‹æ–‡
            )

    def run(self, user_input: Dict[str, Any]) -> Any:
        """
        Orchestrate the  pipeline

        Args:
            user_input: Dictionay containing:
                - raw_query: Original user query string
                - attachments: list of structured attachment data
                - attachment_issues: list of issues identified during preprocessing

        Returns:
            Final answer generated by the AI agent
        """
        try:
            print("\n" + "=" * 80)
            print("ðŸš€ Starting Query Processing Pipeline")
            print("=" * 80)
            start_time = time.time()
            
            # Extract query and context (parsed by pre-processing step)
            query = user_input.get("raw_query", "")
            attachments = user_input.get("attachments", [])
            attachment_contents = [att.get('content', '') for att in attachments]

            print("\nðŸ“¥ **Input Details:**")
            print(f"  - Raw Query: {query}")
            print(f"  - Number of Attachments: {len(attachments)}")
            if attachments:
                print("  - Attachment Details:")
                for i, att in enumerate(attachments, 1):
                    print(f"    {i}. Path: {att.get('path', 'N/A')}, Type: {att.get('type', 'N/A')}")

            # Step 1: Perform query analysis
            print("\nðŸ” **Step 1: Query Analysis**")
            analysis_start = time.time()
            analysis_results = self.query_analyzer.analyze(query=query, attachment_contents=attachment_contents)
            print(f"  - Rewritten Query: {analysis_results['rewritten_query']}")
            # print(f"  - Keywords: {', '.join(analysis_results['keywords'])}")
            # print(f"  - Query Type: {analysis_results['query_type']}")
            print(f"  - Complexity: {analysis_results['complexity']}")
            print(f"  - Domain Areas: {', '.join(analysis_results['domain_areas'])}")

            print("\nâ±ï¸ **Processing Time:**")
            print(f"  - Query Analysis Time: {time.time() - analysis_start:.2f}s")
            print("=" * 80)


            # Step 2: Route to appropriate retrievers
            print("\nðŸ”€ **Step 2: Routing**")
            routing_start = time.time()
            routing_results = self.router.route(analysis_results)
            print(f"  - Routing to: {routing_results['selected_tool']} retriever")
            print(f"  - Reasoning: {routing_results['reasoning']}")
            print(f"  - Retriever Metadata: {routing_results['retrieval_metadata']}")

            print("\nâ±ï¸ **Processing Time:**")
            print(f"  - Routing Analysis Time: {time.time() - routing_start:.2f}s")
            print("=" * 80)


            # Step 3 & 4: Call the selected retriever to get documents and rerank them
            print("\nðŸ“š **Step 3 & 4: Retrieval & Reranking**")
            retrieval_start = time.time()
            reranked_retrieval_results = self._retrieve_documents(routing_results, analysis_results)
            print(f"  - Reranked to final top {len(reranked_retrieval_results.contexts)} documents")
            # for idx, context_doc in enumerate(reranked_retrieval_results.contexts, start=1):
            #     print(f"\n{idx}. Content = {context_doc.content}")

            print("\nâ±ï¸ **Processing Time:**")
            print(f"  - Retrieval & Reranking Time: {time.time() - retrieval_start:.2f}s")
            print("=" * 80)

            # Step 5: Synthesize final answer with rewritten query and reranked contexts
            final_answer = self.synthesizer.synthesize(
                query=analysis_results['rewritten_query'],
                rerank_result=reranked_retrieval_results,
            )

            # æŠŠä¸Šä¸‹æ–‡è½¬æ¢æˆ CLI ç”¨çš„ sources åˆ—è¡¨
            sources = final_answer.to_sources()

            print(f"âœï¸ Generated answer with {len(sources)} sources")
            print(f"â±ï¸ Total time: {time.time() - start_time:.2f} seconds")
            print("===========================")

            return {
                "answer": final_answer.answer,
                "sources": sources,
                "confidence": 1.0,
                "analysis_results": analysis_results,
                "llm_metadata": final_answer.metadata,
            }

            # return {
            #     'answer': final_answer['answer'],
            #     'sources': final_answer['sources'],
            #     'confidence': final_answer.get('confidence', 0.0),
            #     'routing_info': routing_results,
            #     'retrieval_count': len(retrieval_results),
            #     'reranked_count': len(reranked_results)
            # }
    
        except Exception as e:
            print(f"âŒ Error during query processing: {e}")
            return {
                'answer': f"Sorry, an error occurred while processing your query: {str(e)}",
                'sources': [],
                'confidence': 0.0,
                'error': str(e)
            }

    async def health_check(self) -> Dict[str, bool]:
        """Check health status of each component"""
        try:
            return {
                'query_analyzer': await self.query_analyzer.health_check(),
                'router': await self.router.health_check(),
                # Comment out this line since retrieval_manager is not initialized
                # 'retrieval_manager': await self.retrieval_manager.health_check(),
                'reranker': await self.reranker.health_check(),
                'synthesizer': await self.synthesizer.health_check()
            }
        except Exception as e:
            print(f"Health check error: {e}")
            return {
                'query_analyzer': False,
                'router': False,
                'retrieval_manager': False,  # You can keep this in the error return
                'reranker': False,
                'synthesizer': False
            }